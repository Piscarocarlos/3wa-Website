{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\nimport React, { createContext, useMemo, useContext, useState, useRef, useEffect, useCallback } from \"react\";\nimport _topbar from \"topbar\";\nimport { Route as Route$1, matchRoutes, useRoutes, UNSAFE_LocationContext, useLocation, useNavigationType } from \"react-router\";\nconst LoadingContext = createContext({\n  start: () => {},\n  done: () => {},\n  restart: () => {}\n});\nLoadingContext.displayName = \"LoadingContext\";\nconst LoadingGetterContext = createContext(false);\nLoadingGetterContext.displayName = \"LoadingGetterContext\";\nvar jsxRuntime = {\n  exports: {}\n};\nvar reactJsxRuntime_production_min = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar f = React,\n  k = Symbol.for(\"react.element\"),\n  l = Symbol.for(\"react.fragment\"),\n  m = Object.prototype.hasOwnProperty,\n  n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,\n  p = {\n    key: true,\n    ref: true,\n    __self: true,\n    __source: true\n  };\nfunction q(c, a, g) {\n  var b,\n    d = {},\n    e = null,\n    h = null;\n  g !== void 0 && (e = \"\" + g);\n  a.key !== void 0 && (e = \"\" + a.key);\n  a.ref !== void 0 && (h = a.ref);\n  for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);\n  if (c && c.defaultProps) for (b in a = c.defaultProps, a) d[b] === void 0 && (d[b] = a[b]);\n  return {\n    $$typeof: k,\n    type: c,\n    key: e,\n    ref: h,\n    props: d,\n    _owner: n.current\n  };\n}\nreactJsxRuntime_production_min.Fragment = l;\nreactJsxRuntime_production_min.jsx = q;\nreactJsxRuntime_production_min.jsxs = q;\n{\n  jsxRuntime.exports = reactJsxRuntime_production_min;\n}\nconst jsx = jsxRuntime.exports.jsx;\nconst jsxs = jsxRuntime.exports.jsxs;\nconst Fragment = jsxRuntime.exports.Fragment;\nconst Route = _a => {\n  var _b = _a,\n    {\n      loading\n    } = _b,\n    props = __objRest(_b, [\"loading\"]);\n  return /* @__PURE__ */jsx(Route$1, __spreadValues({}, props));\n};\nconst DefaultLoadingScreen = () => /* @__PURE__ */jsx(\"div\", {\n  style: {\n    position: \"fixed\",\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    backgroundColor: \"white\"\n  }\n});\nfunction createRoutesFromChildren(children) {\n  const routes = [];\n  React.Children.forEach(children, element => {\n    if (!React.isValidElement(element)) {\n      return;\n    }\n    if (element.type === React.Fragment) {\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children));\n      return;\n    }\n    const route = {\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path,\n      loading: element.props.loading\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children);\n    }\n    routes.push(route);\n  });\n  return routes;\n}\nconst isPathsDifferent = (first, second) => first.pathname !== second.pathname;\nconst isPathsEqual = (first, second) => first.pathname === second.pathname;\nconst isSearchDifferent = (first, second) => first.search !== second.search;\nconst isLoadable = (location, routes) => {\n  const matches = matchRoutes(routes, location);\n  if (!matches || matches.length === 0) return false;\n  const lastMatch = matches[matches.length - 1];\n  return lastMatch.route.loading;\n};\nconst RouteWrapper = _ref => {\n  let {\n    routes,\n    location,\n    navigationType,\n    hidden\n  } = _ref;\n  const element = useRoutes(routes, location);\n  return /* @__PURE__ */jsx(\"div\", {\n    style: hidden ? {\n      display: \"none\"\n    } : void 0,\n    children: useMemo(() => /* @__PURE__ */jsx(UNSAFE_LocationContext.Provider, {\n      value: {\n        location,\n        navigationType\n      },\n      children: element\n    }), [location])\n  });\n};\nconst LOADING_PATHNAME = \"__loading\";\nconst LoadingRoutes = _ref2 => {\n  let {\n    children,\n    loadingScreen: LoadingScreen,\n    maxLoadingTime = 0\n  } = _ref2;\n  const location = useLocation();\n  const navigationType = useNavigationType();\n  const loadingContext = useContext(LoadingContext);\n  const isCurrentlyLoading = useContext(LoadingGetterContext);\n  const routes = useMemo(() => createRoutesFromChildren(children), [children]);\n  const [current, setCurrent] = useState(() => {\n    const isFirstPageLoadable = isLoadable(location, routes);\n    const firstLocation = isFirstPageLoadable ? __spreadProps(__spreadValues({}, location), {\n      pathname: LOADING_PATHNAME\n    }) : location;\n    return {\n      location: firstLocation,\n      navigationType\n    };\n  });\n  const [next, setNext] = useState(current);\n  const timeout = useRef();\n  useEffect(() => {\n    if (isPathsDifferent(location, next.location)) {\n      const isPageLoadable = isLoadable(location, routes);\n      setNext({\n        location: __spreadValues({}, location),\n        navigationType\n      });\n      if (!isPageLoadable) {\n        loadingContext.done();\n        setCurrent({\n          location: __spreadValues({}, location),\n          navigationType\n        });\n      } else {\n        if (!isCurrentlyLoading) loadingContext.start();else loadingContext.restart();\n      }\n    }\n    if (isPathsEqual(location, current.location)) {\n      loadingContext.done();\n      if (isSearchDifferent(location, current.location)) setCurrent({\n        location: __spreadValues({}, location),\n        navigationType\n      });\n    }\n  }, [location]);\n  useEffect(() => {\n    if (!isCurrentlyLoading && isPathsDifferent(current.location, next.location)) setCurrent(next);\n  }, [isCurrentlyLoading]);\n  useEffect(() => {\n    if (maxLoadingTime > 0) {\n      if (timeout.current) {\n        clearTimeout(timeout.current);\n        timeout.current = void 0;\n      }\n      if (isPathsDifferent(current.location, next.location)) {\n        timeout.current = setTimeout(() => {\n          loadingContext.done();\n        }, maxLoadingTime);\n      }\n    }\n  }, [current, next]);\n  return useMemo(() => /* @__PURE__ */jsxs(Fragment, {\n    children: [current.location.pathname !== LOADING_PATHNAME ? /* @__PURE__ */jsx(RouteWrapper, {\n      routes,\n      location: current.location,\n      navigationType: current.navigationType\n    }, current.location.pathname) : LoadingScreen ? /* @__PURE__ */jsx(LoadingScreen, {}) : /* @__PURE__ */jsx(DefaultLoadingScreen, {}), isPathsDifferent(current.location, next.location) && /* @__PURE__ */jsx(RouteWrapper, {\n      routes,\n      location: next.location,\n      navigationType: next.navigationType,\n      hidden: true\n    }, next.location.pathname)]\n  }), [current, next]);\n};\nconst LoadingMiddleware = _ref3 => {\n  let {\n    children,\n    isLoading = false\n  } = _ref3;\n  const [loading, setLoading] = useState(isLoading);\n  const isFirstRender = useRef(true);\n  const start = useCallback(() => {\n    topbar.show();\n    setLoading(true);\n  }, []);\n  const done = useCallback(() => {\n    topbar.hide();\n    setLoading(false);\n  }, []);\n  const restart = useCallback(() => {\n    topbar.hide();\n    topbar.show();\n  }, []);\n  useEffect(() => {\n    if (!isFirstRender.current) {\n      if (isLoading && !loading) start();else if (loading) done();\n    } else {\n      isFirstRender.current = false;\n    }\n  }, [isLoading]);\n  const loadingProvider = useMemo(() => /* @__PURE__ */jsx(LoadingContext.Provider, {\n    value: {\n      start,\n      done,\n      restart\n    },\n    children\n  }), []);\n  return /* @__PURE__ */jsx(LoadingGetterContext.Provider, {\n    value: loading,\n    children: loadingProvider\n  });\n};\nconst Routes = _ref4 => {\n  let {\n    children,\n    loadingScreen,\n    maxLoadingTime,\n    isLoading\n  } = _ref4;\n  return /* @__PURE__ */jsx(LoadingMiddleware, {\n    isLoading,\n    children: /* @__PURE__ */jsx(LoadingRoutes, {\n      loadingScreen,\n      maxLoadingTime,\n      children\n    })\n  });\n};\nconst topbar = _topbar;\nconst useLoadingContext = () => useContext(LoadingContext);\nexport { LoadingContext, LoadingGetterContext, Route, Routes, topbar, useLoadingContext };","map":{"version":3,"mappings":"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","names":["LoadingContext","createContext","start","done","restart","displayName","LoadingGetterContext","f","require$$0","k","Symbol","for","l","m","Object","prototype","hasOwnProperty","n","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","p","key","ref","__self","__source","c","a","g","b","d","e","h","call","defaultProps","$$typeof","type","props","_owner","current","reactJsxRuntime_production_min","q","jsxRuntimeModule","jsx","jsxRuntime.jsx","exports","jsxs","jsxRuntime.jsxs","Fragment","jsxRuntime.Fragment","Route","_a","loading","_b","OriginalRoute","DefaultLoadingScreen","_jsx","style","position","top","bottom","left","right","backgroundColor","children","routes","React","forEach","element","isValidElement","push","apply","createRoutesFromChildren","route","caseSensitive","index","path","isPathsDifferent","first","second","pathname","isPathsEqual","isSearchDifferent","search","isLoadable","location","matchRoutes","matches","length","lastMatch","RouteWrapper","_ref","navigationType","hidden","useRoutes","display","undefined","useMemo","UNSAFE_LocationContext","Provider","value","LOADING_PATHNAME","LoadingRoutes","_ref2","loadingScreen","LoadingScreen","maxLoadingTime","useLocation","useNavigationType","loadingContext","useContext","isCurrentlyLoading","setCurrent","useState","isFirstPageLoadable","firstLocation","__spreadProps","next","setNext","timeout","useRef","useEffect","isPageLoadable","__spreadValues","clearTimeout","setTimeout","_jsxs","LoadingMiddleware","_ref3","isLoading","setLoading","isFirstRender","useCallback","topbar","show","hide","loadingProvider","Routes","_ref4","_topbar","useLoadingContext"],"sources":["/Users/idrisssemraoui/Desktop/3wa-Website/node_modules/react-router-loading/lib/LoadingContext.ts","/Users/idrisssemraoui/Desktop/3wa-Website/node_modules/react/cjs/react-jsx-runtime.production.min.js","/Users/idrisssemraoui/Desktop/3wa-Website/node_modules/react/jsx-runtime.js","/Users/idrisssemraoui/Desktop/3wa-Website/node_modules/react-router-loading/react/jsx-runtime","/Users/idrisssemraoui/Desktop/3wa-Website/node_modules/react-router-loading/lib/Route.tsx","/Users/idrisssemraoui/Desktop/3wa-Website/node_modules/react-router-loading/lib/_DefaultLoadingScreen.tsx","/Users/idrisssemraoui/Desktop/3wa-Website/node_modules/react-router-loading/lib/utils.ts","/Users/idrisssemraoui/Desktop/3wa-Website/node_modules/react-router-loading/lib/_RouteWrapper.tsx","/Users/idrisssemraoui/Desktop/3wa-Website/node_modules/react-router-loading/lib/_LoadingRoutes.tsx","/Users/idrisssemraoui/Desktop/3wa-Website/node_modules/react-router-loading/lib/_LoadingMiddleware.tsx","/Users/idrisssemraoui/Desktop/3wa-Website/node_modules/react-router-loading/lib/Routes.tsx","/Users/idrisssemraoui/Desktop/3wa-Website/node_modules/react-router-loading/lib/index.ts"],"sourcesContent":["import { createContext } from 'react';\n\n// Interface\n\nexport interface LoadingContextActions {\n  start: () => void;\n  done: () => void;\n  restart: () => void;\n}\n\n// Actions\n\nconst LoadingContext = createContext<LoadingContextActions>({\n  start: () => { },\n  done: () => { },\n  restart: () => { }\n});\nLoadingContext.displayName = 'LoadingContext';\n\n// Value\n\nconst LoadingGetterContext = createContext<boolean>(false);\nLoadingGetterContext.displayName = 'LoadingGetterContext';\n\nexport {\n  LoadingContext,\n  LoadingGetterContext\n};\n","/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var f=require(\"react\"),k=Symbol.for(\"react.element\"),l=Symbol.for(\"react.fragment\"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=\"\"+g);void 0!==a.key&&(e=\"\"+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","import * as jsxRuntime from \"/Users/victor/Projects/own/react-router-loading/node_modules/react/jsx-runtime.js\"\nexport const jsx = jsxRuntime.jsx\nexport const jsxs = jsxRuntime.jsxs\nexport const Fragment = jsxRuntime.Fragment","import React, { FC } from 'react';\nimport { Route as OriginalRoute, RouteProps as OriginalRouteProps } from 'react-router';\n\ninterface RouteProps extends OriginalRouteProps {\n  loading?: boolean;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst Route: FC<RouteProps> = ({ loading, ...props }) => <OriginalRoute {...props} />;\n\nexport default Route;\n","import React, { FC } from 'react';\n\nconst DefaultLoadingScreen: FC = () =>\n  <div\n    style={{\n      position: 'fixed',\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      backgroundColor: 'white'\n    }}\n  />;\n\nexport default DefaultLoadingScreen;\n","import React from 'react';\nimport { matchRoutes, RouteObject, Location } from 'react-router';\n\nexport interface LoadingRouteObject extends RouteObject {\n  loading?: boolean;\n}\n\n// adapted from original createRoutesFromChildren\n// https://github.com/remix-run/react-router/blob/main/packages/react-router/lib/components.tsx\nexport function createRoutesFromChildren(children: React.ReactNode): LoadingRouteObject[] {\n  const routes: LoadingRouteObject[] = [];\n\n  React.Children.forEach(children, element => {\n    if (!React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      // eslint-disable-next-line prefer-spread\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children));\n      return;\n    }\n\n    const route: LoadingRouteObject = {\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path,\n      loading: element.props.loading,\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children);\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\nexport const isPathsDifferent = (first: Location, second: Location) =>\n  first.pathname !== second.pathname;\n\nexport const isPathsEqual = (first: Location, second: Location) =>\n  first.pathname === second.pathname;\n\nexport const isSearchDifferent = (first: Location, second: Location) =>\n  first.search !== second.search;\n\nexport const isLoadable = (location: Location, routes: LoadingRouteObject[]) => {\n  const matches = matchRoutes(routes, location);\n\n  if (!matches || matches.length === 0)\n    return false;\n\n  const lastMatch = matches[matches.length - 1];\n  return (lastMatch.route as LoadingRouteObject).loading;\n};\n","/* eslint-disable camelcase */\nimport React, { useMemo, FC } from 'react';\nimport { Location, NavigationType, UNSAFE_LocationContext, useRoutes } from 'react-router';\nimport { LoadingRouteObject } from './utils';\n\ninterface RouteWrapperProps {\n  routes: LoadingRouteObject[];\n  location: Location;\n  navigationType: NavigationType;\n  hidden?: boolean;\n}\n\nexport const RouteWrapper: FC<RouteWrapperProps> = ({ routes, location, navigationType, hidden }) => {\n  const element = useRoutes(routes, location);\n\n  return <div style={hidden ? { display: 'none' } : undefined}>\n    {useMemo(\n      () => <UNSAFE_LocationContext.Provider value={{ location, navigationType }}>\n        {element}\n      </UNSAFE_LocationContext.Provider>,\n      [location]\n    )}\n  </div>;\n};\n","\nimport React, { useState, useContext, useEffect, useMemo, useRef, PropsWithChildren, FC } from 'react';\nimport { useLocation, Location, useNavigationType, NavigationType } from 'react-router';\nimport { LoadingContext, LoadingGetterContext } from './LoadingContext';\nimport DefaultLoadingScreen from './_DefaultLoadingScreen';\nimport { createRoutesFromChildren, isLoadable, isPathsDifferent, isPathsEqual, isSearchDifferent } from './utils';\nimport { RouteWrapper } from './_RouteWrapper';\n\ninterface LoadingRoutesProps {\n  loadingScreen?: React.ElementType;\n  maxLoadingTime?: number;\n}\n\ninterface LoadingRoutesState {\n  location: Location;\n  navigationType: NavigationType;\n}\n\nconst LOADING_PATHNAME = '__loading';\n\nconst LoadingRoutes: FC<PropsWithChildren<LoadingRoutesProps>> = ({\n  children,\n  loadingScreen: LoadingScreen,\n  maxLoadingTime = 0\n}) => {\n\n  // ðŸª Hooks\n  const location = useLocation();\n  const navigationType = useNavigationType();\n  const loadingContext = useContext(LoadingContext);\n  const isCurrentlyLoading = useContext(LoadingGetterContext);\n\n  // ðŸ—„ State\n  const routes = useMemo(\n    () => createRoutesFromChildren(children),\n    [children]\n  );\n\n  const [current, setCurrent] = useState<LoadingRoutesState>(() => {\n    const isFirstPageLoadable = isLoadable(location, routes);\n\n    // if first page loadable showing loading screen\n    const firstLocation = isFirstPageLoadable\n      ? { ...location, pathname: LOADING_PATHNAME }\n      : location;\n\n    return {\n      location: firstLocation,\n      navigationType: navigationType\n    };\n  });\n  const [next, setNext] = useState<LoadingRoutesState>(current);\n\n  const timeout: React.MutableRefObject<NodeJS.Timeout | undefined> = useRef();\n\n  // ðŸ”„ Lifecycle\n  // when location was changed\n  useEffect(() => {\n    // if not the same route mount it to start loading\n    if (isPathsDifferent(location, next.location)) {\n      const isPageLoadable = isLoadable(location, routes);\n\n      setNext({\n        location: { ...location },\n        navigationType\n      });\n\n      if (!isPageLoadable) {\n        loadingContext.done();\n        setCurrent({\n          location: { ...location },\n          navigationType\n        });\n      } else {\n        if (!isCurrentlyLoading)\n          loadingContext.start();\n        else\n          loadingContext.restart();\n      }\n    }\n\n    // if same as the current location stop loading\n    if (isPathsEqual(location, current.location)) {\n      loadingContext.done();\n\n      if (isSearchDifferent(location, current.location))\n        setCurrent({\n          location: { ...location },\n          navigationType\n        });\n    }\n  }, [location]);\n\n  // when loading is done\n  useEffect(() => {\n    if (!isCurrentlyLoading && isPathsDifferent(current.location, next.location))\n      setCurrent(next);\n  }, [isCurrentlyLoading]);\n\n  // setTimeout if maxLoadingTime is provided\n  useEffect(() => {\n    if (maxLoadingTime > 0) {\n      if (timeout.current) {\n        clearTimeout(timeout.current);\n        timeout.current = undefined;\n      }\n\n      if (isPathsDifferent(current.location, next.location)) {\n        timeout.current = setTimeout(() => {\n          loadingContext.done();\n        }, maxLoadingTime);\n      }\n    }\n  }, [current, next]);\n\n  // memo current and next components\n  return useMemo(\n    () => <>\n      {/* current */}\n      {\n        current.location.pathname !== LOADING_PATHNAME\n          ? <RouteWrapper\n            key={current.location.pathname}\n            routes={routes}\n            location={current.location}\n            navigationType={current.navigationType}\n          />\n          : LoadingScreen\n            ? <LoadingScreen />\n            : <DefaultLoadingScreen />\n      }\n\n      {/* hidden next */}\n      {\n        isPathsDifferent(current.location, next.location) &&\n        <RouteWrapper\n          key={next.location.pathname}\n          routes={routes}\n          location={next.location}\n          navigationType={next.navigationType}\n          hidden\n        />\n      }\n    </>,\n    [current, next]\n  );\n};\n\nexport default LoadingRoutes;\n","import React, { useState, useMemo, useCallback, useEffect, useRef, FC, PropsWithChildren } from 'react';\nimport { LoadingContext, LoadingGetterContext } from './LoadingContext';\nimport { topbar } from '.';\n\nconst LoadingMiddleware: FC<PropsWithChildren<{ isLoading?: boolean }>> = ({ children, isLoading = false }) => {\n  const [loading, setLoading] = useState(isLoading);\n  const isFirstRender = useRef(true);\n\n  const start = useCallback(() => {\n    topbar.show();\n    setLoading(true);\n  }, []);\n\n  const done = useCallback(() => {\n    topbar.hide();\n    setLoading(false);\n  }, []);\n\n  const restart = useCallback(() => {\n    topbar.hide();\n    topbar.show();\n  }, []);\n\n  useEffect(() => {\n    if (!isFirstRender.current) {\n      if (isLoading && !loading)\n        start();\n      else if (loading)\n        done();\n    } else {\n      isFirstRender.current = false;\n    }\n  }, [isLoading]);\n\n  const loadingProvider = useMemo(\n    () => <LoadingContext.Provider value={{ start, done, restart }}>\n      {children}\n    </LoadingContext.Provider>,\n    []\n  );\n\n  return (\n    <LoadingGetterContext.Provider value={loading}>\n      {loadingProvider}\n    </LoadingGetterContext.Provider>\n  );\n};\n\nexport default LoadingMiddleware;\n","import React, { ElementType, FC, ReactNode } from 'react';\nimport LoadingRoutes from './_LoadingRoutes';\nimport LoadingMiddleware from './_LoadingMiddleware';\n\ninterface RoutesProps {\n  children: ReactNode;\n  loadingScreen?: ElementType;\n  maxLoadingTime?: number;\n  isLoading?: boolean;\n}\n\n// combine topbar and switcher\nconst Routes: FC<RoutesProps> = ({ children, loadingScreen, maxLoadingTime, isLoading }) =>\n  <LoadingMiddleware isLoading={isLoading}>\n    <LoadingRoutes loadingScreen={loadingScreen} maxLoadingTime={maxLoadingTime}>\n      {children}\n    </LoadingRoutes>\n  </LoadingMiddleware>;\n\nexport default Routes;\n","import { useContext } from 'react';\nimport { default as _topbar } from 'topbar';\nimport { LoadingContext, LoadingGetterContext } from './LoadingContext';\n\nexport { default as Route } from './Route';\nexport { default as Routes } from './Routes';\n\nexport interface TopBarConfig {\n  autoRun?: boolean;\n  barThickness?: number;\n  barColors?: Record<number, string>;\n  shadowBlur?: number;\n  shadowColor?: string;\n  className?: string;\n}\n\nexport interface TopBar {\n  show: () => void;\n  hide: () => void;\n  config: (conf: TopBarConfig) => void;\n}\n\nconst topbar: TopBar = _topbar;\n\nconst useLoadingContext = () => useContext(LoadingContext);\n\nexport {\n  topbar,\n  useLoadingContext,\n  LoadingContext,\n  LoadingGetterContext\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}